package com.hedera.hashgraph.sdk.crypto;

import com.hedera.hashgraph.sdk.Internal;
import com.hedera.hashgraph.sdk.crypto.ed25519.Ed25519PrivateKey;

import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;
import org.bouncycastle.crypto.params.KeyParameter;

import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.annotation.Nullable;

import io.github.novacrypto.bip39.MnemonicGenerator;
import io.github.novacrypto.bip39.wordlists.English;

/**
 * BIP-39 mnemonic phrases compatible with the Android and iOS mobile wallets.
 */
public final class Mnemonic {
    /**
     * The list of words in this mnemonic.
     */
    public final List<CharSequence> words;

    @Nullable
    private String asString;

    private static final MnemonicGenerator generator = new MnemonicGenerator(English.INSTANCE);

    private static final SecureRandom secureRandom = new SecureRandom();

    private static final Set<CharSequence> wordList;

    static {
        // the BIP39 lib doesn't give us direct access to the word list
        HashSet<String> newWordList = new HashSet<>(2048);

        for (int i = 0; i < 2048; i++) {
            newWordList.add(English.INSTANCE.getWord(i));
        }

        wordList = Collections.unmodifiableSet(newWordList);
    }

    /**
     * Construct a mnemonic from a 24-word list.
     *
     * @throws BadMnemonicError if {@code words.size() != 24} or if any words in the list do not
     * exist in the BIP-39 standard English word list (as typo detection).
     *
     * @param words the 24-word list that constitutes a mnemonic phrase.
     */
    public Mnemonic(List<? extends CharSequence> words) {
        if (words.size() != 24) {
            throw new BadMnemonicError("expected 24-word mnemonic, got " + words.size() + " words");
        }

        ArrayList<Integer> unknownIndices = new ArrayList<>();

        for (int i = 0; i < words.size(); i++) {
            if (!wordList.contains(words.get(i))) {
                unknownIndices.add(i);
            }
        }

        if (!unknownIndices.isEmpty()) {
            String unknownWords = String.join(
                ", ",
                unknownIndices.stream().map(i -> (CharSequence) words.get(i))::iterator);

            throw new BadMnemonicError(
                "the following words in the mnemonic were not in the word list: " + unknownWords,
                unknownIndices);
        }

        this.words = Collections.unmodifiableList(words);
    }

    /**
     * Recover a mnemonic from a string, splitting on spaces.
     *
     * @throws BadMnemonicError if the string does not contain 24 words or if any words in the string
     * do not exist in the BIP-39 standard English word list (as typo detection).
     * @param mnemonicString
     * @return
     */
    public static Mnemonic fromString(String mnemonicString) {
        return new Mnemonic(Arrays.asList(mnemonicString.split(" ")));
    }

    /**
     * @return a new random 24-word mnemonic from the BIP-39 standard English word list.
     */
    public static Mnemonic generate() {
        final byte[] entropy = new byte[32];
        secureRandom.nextBytes(entropy);

        final ArrayList<CharSequence> wordList = new ArrayList<>(24);

        generator.createMnemonic(entropy, word -> {
            // the generator spits out spaces whether you want them or not
            if (!word.toString().equals(" ")) {
                wordList.add(word);
            }
        });

        return new Mnemonic(wordList);
    }

    /**
     * Recover a private key from this mnemonic phrase.
     *
     * This is not compatible with the phrases generated by the Android and iOS wallets;
     * use the no-passphrase version instead.
     *
     * @param passphrase the passphrase used to protect the mnemonic (not used in the
     *                   mobile wallets, use {@link #toPrivateKey()} instead.)
     * @return the recovered key; use {@link Ed25519PrivateKey#derive(int)} to get a key for an
     * account index (0 for default account)
     * @see Ed25519PrivateKey#fromMnemonic(Mnemonic, String)
     */
    public Ed25519PrivateKey toPrivateKey(String passphrase) {
        return Ed25519PrivateKey.fromMnemonic(this, passphrase);
    }

    /**
     * Recover a private key from this mnemonic phrase.
     *
     * @return the recovered key; use {@link Ed25519PrivateKey#derive(int)} to get a key for an
     * account index (0 for default account)
     * @see Ed25519PrivateKey#fromMnemonic(Mnemonic)
     */
    public Ed25519PrivateKey toPrivateKey() {
        return toPrivateKey("");
    }

    @Override
    public String toString() {
        if (asString == null) {
            asString = String.join(" ", words);
        }

        return asString;
    }

    @Internal
    public byte[] toSeed(String passphrase) {
        final String salt = "mnemonic" + passphrase;

        // BIP-39 seed generation
        final PKCS5S2ParametersGenerator pbkdf2 = new PKCS5S2ParametersGenerator(new SHA512Digest());
        pbkdf2.init(
            toString().getBytes(StandardCharsets.UTF_8),
            salt.getBytes(StandardCharsets.UTF_8),
            2048);

        final KeyParameter key = (KeyParameter) pbkdf2.generateDerivedParameters(512);
        return key.getKey();
    }
}
